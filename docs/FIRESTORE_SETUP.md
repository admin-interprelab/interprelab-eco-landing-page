# Firestore Backend Integration Guide

This document provides comprehensive instructions for setting up Firebase Firestore as the backend for the InterpreLab landing page.

## Table of Contents
1. [Collection Structures](#collection-structures)
2. [Required Indexes](#required-indexes)
3. [Security Rules](#security-rules)
4. [CRUD Operations](#crud-operations)
5. [Quick Start Checklist](#quick-start-checklist)

## Collection Structures

### 1. FAQs Collection (`faqs`)

Stores frequently asked questions displayed on the landing page.

```typescript
interface FAQDocument {
  id: string;                    // Auto-generated by Firestore
  question: string;              // Required: The question text
  answer: string;                // Required: The answer text
  category: string;              // Required: 'general' | 'products' | 'pricing' | 'technical' | 'privacy' | 'support'
  priority: number;              // Required: 1-100 (higher = shown first)
  helpfulCount: number;          // Default: 0
  notHelpfulCount: number;       // Default: 0
  createdAt: Timestamp;          // Auto-generated
  updatedAt: Timestamp;          // Auto-generated
}
```

**Example Document:**
```json
{
  "question": "What is InterpreLab?",
  "answer": "InterpreLab is an AI-powered ecosystem for medical interpreters...",
  "category": "general",
  "priority": 100,
  "helpfulCount": 42,
  "notHelpfulCount": 3,
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-15T10:30:00Z"
}
```

### 2. Resources Collection (`resources`)

Stores resource articles and documents featured on the Resources page.

```typescript
interface ResourceDocument {
  id: string;                    // Auto-generated
  title: string;                 // Required
  description: string;           // Required
  content: string;               // Required (markdown or HTML)
  category: string;              // Required: 'article' | 'report' | 'documentation' | 'guide'
  featured: boolean;             // Default: false
  thumbnailUrl: string;          // Required (URL to thumbnail image)
  href: string;                  // Required (internal or external link)
  publishedDate: Timestamp;      // Required
  author: string;                // Optional
  tags: string[];                // Optional
  viewCount: number;             // Default: 0
  createdAt: Timestamp;          // Auto-generated
  updatedAt: Timestamp;          // Auto-generated
}
```

**Example Document:**
```json
{
  "title": "The Interpreter Dilemma",
  "description": "An interactive report on misclassification and wage theft...",
  "content": "Full markdown content here...",
  "category": "report",
  "featured": true,
  "thumbnailUrl": "https://example.com/dilemma-thumb.jpg",
  "href": "/dilemma",
  "publishedDate": "2024-01-01T00:00:00Z",
  "author": "InterpreLab Research Team",
  "tags": ["wage-theft", "misclassification", "industry-report"],
  "viewCount": 1523,
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-15T10:30:00Z"
}
```

### 3. Certificates Collection (`certificates`)

Stores certificate and premium membership information.

```typescript
interface CertificateDocument {
  id: string;                    // Auto-generated
  title: string;                 // Required
  subtitle: string;              // Required
  description: string;           // Required
  price: number;                 // Required
  currency: string;              // Default: 'USD'
  features: string[];            // Required (list of features)
  comingSoon: boolean;           // Default: false
  enrollmentUrl: string;         // Optional
  imageUrl: string;              // Optional (certificate image)
  displayOrder: number;          // Required: for sorting
  createdAt: Timestamp;          // Auto-generated
  updatedAt: Timestamp;          // Auto-generated
}
```

**Example Document:**
```json
{
  "title": "NBCMI Prerequisite Course",
  "subtitle": "40-Hour Medical Interpreter Training",
  "description": "Comprehensive training approved by NBCMI...",
  "price": 599,
  "currency": "USD",
  "features": [
    "40 hours of instruction",
    "NBCMI approved",
    "Certificate of completion",
    "Lifetime access"
  ],
  "comingSoon": false,
  "enrollmentUrl": "https://interprelab.com/enroll/nbcmi",
  "imageUrl": "https://example.com/cert-nbcmi.jpg",
  "displayOrder": 1,
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-15T10:30:00Z"
}
```

## Required Indexes

To enable efficient querying, create the following composite indexes in Firestore:

### FAQs Indexes
1. **Category + Priority (Descending)**
   - Collection: `faqs`
   - Fields: `category` (Ascending), `priority` (Descending)
   - Query scope: Collection

2. **Priority (Descending) - Single Field**
   - Collection: `faqs`
   - Field: `priority` (Descending)
   - Query scope: Collection

### Resources Indexes
1. **Featured + Published Date**
   - Collection: `resources`
   - Fields: `featured` (Descending), `publishedDate` (Descending)
   - Query scope: Collection

2. **Category + Published Date**
   - Collection: `resources`
   - Fields: `category` (Ascending), `publishedDate` (Descending)
   - Query scope: Collection

3. **Published Date (Single Field)**
   - Collection: `resources`
   - Field: `publishedDate` (Descending)
   - Query scope: Collection

### Certificates Indexes
1. **Display Order (Single Field)**
   - Collection: `certificates`
   - Field: `displayOrder` (Ascending)
   - Query scope: Collection

**To create indexes via Firebase Console:**
1. Go to Firebase Console → Firestore Database
2. Click on "Indexes" tab
3. Click "Add Index"
4. Select collection and fields as specified above

## Security Rules

Configure Firestore security rules to allow public read access and admin-only write access:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is admin
    function isAdmin() {
      return request.auth != null && 
             request.auth.token.admin == true;
    }
    
    // FAQs Collection - Public read, admin write
    match /faqs/{faqId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
      
      // Allow users to increment helpful/notHelpful counts
      allow update: if request.resource.data.diff(resource.data).affectedKeys()
                      .hasOnly(['helpfulCount', 'notHelpfulCount']);
    }
    
    // Resources Collection - Public read, admin write
    match /resources/{resourceId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
      
      // Allow view count increments
      allow update: if request.resource.data.diff(resource.data).affectedKeys()
                      .hasOnly(['viewCount']);
    }
    
    // Certificates Collection - Public read, admin write
    match /certificates/{certId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }
  }
}
```

**To deploy security rules:**
```bash
firebase deploy --only firestore:rules
```

## CRUD Operations

### Service File Structure

Create service files in `src/services/` to handle Firestore operations:

#### FAQ Service (`src/services/faqService.ts`)

```typescript
import { 
  collection, 
  getDocs, 
  getDoc,
  doc,
  query, 
  orderBy, 
  limit,
  where,
  addDoc,
  updateDoc,
  deleteDoc,
  Timestamp 
} from 'firebase/firestore';
import { db } from './firebase/config';

export interface FAQItem {
  id: string;
  question: string;
  answer: string;
  category: string;
  priority: number;
  helpfulCount: number;
  notHelpfulCount: number;
  createdAt: Timestamp;
  updatedAt: Timestamp;
}

// READ: Get all FAQs or limited number
export const getFAQs = async (limitCount?: number): Promise<FAQItem[]> => {
  try {
    const faqsRef = collection(db, 'faqs');
    const q = limitCount
      ? query(faqsRef, orderBy('priority', 'desc'), limit(limitCount))
      : query(faqsRef, orderBy('priority', 'desc'));
    
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ 
      id: doc.id, 
      ...doc.data() 
    } as FAQItem));
  } catch (error) {
    console.error('Error fetching FAQs:', error);
    throw error;
  }
};

// READ: Get FAQs by category
export const getFAQsByCategory = async (category: string): Promise<FAQItem[]> => {
  try {
    const faqsRef = collection(db, 'faqs');
    const q = query(
      faqsRef,
      where('category', '==', category),
      orderBy('priority', 'desc')
    );
    
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ 
      id: doc.id, 
      ...doc.data() 
    } as FAQItem));
  } catch (error) {
    console.error('Error fetching FAQs by category:', error);
    throw error;
  }
};

// READ: Get single FAQ by ID
export const getFAQById = async (id: string): Promise<FAQItem | null> => {
  try {
    const docRef = doc(db, 'faqs', id);
    const docSnap = await getDoc(docRef);
    
    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() } as FAQItem;
    }
    return null;
  } catch (error) {
    console.error('Error fetching FAQ:', error);
    throw error;
  }
};

// CREATE: Add new FAQ (admin only)
export const createFAQ = async (
  faqData: Omit<FAQItem, 'id' | 'createdAt' | 'updatedAt'>
): Promise<string> => {
  try {
    const docRef = await addDoc(collection(db, 'faqs'), {
      ...faqData,
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    });
    return docRef.id;
  } catch (error) {
    console.error('Error creating FAQ:', error);
    throw error;
  }
};

// UPDATE: Update existing FAQ (admin only)
export const updateFAQ = async (
  id: string, 
  updates: Partial<Omit<FAQItem, 'id' | 'createdAt'>>
): Promise<void> => {
  try {
    const docRef = doc(db, 'faqs', id);
    await updateDoc(docRef, {
      ...updates,
      updatedAt: Timestamp.now(),
    });
  } catch (error) {
    console.error('Error updating FAQ:', error);
    throw error;
  }
};

// DELETE: Delete FAQ (admin only)
export const deleteFAQ = async (id: string): Promise<void> => {
  try {
    const docRef = doc(db, 'faqs', id);
    await deleteDoc(docRef);
  } catch (error) {
    console.error('Error deleting FAQ:', error);
    throw error;
  }
};

// Increment helpful count
export const incrementHelpful = async (id: string): Promise<void> => {
  try {
    const faq = await getFAQById(id);
    if (faq) {
      await updateFAQ(id, { 
        helpfulCount: faq.helpfulCount + 1 
      });
    }
  } catch (error) {
    console.error('Error incrementing helpful count:', error);
    throw error;
  }
};

// Increment not helpful count
export const incrementNotHelpful = async (id: string): Promise<void> => {
  try {
    const faq = await getFAQById(id);
    if (faq) {
      await updateFAQ(id, { 
        notHelpfulCount: faq.notHelpfulCount + 1 
      });
    }
  } catch (error) {
    console.error('Error incrementing not helpful count:', error);
    throw error;
  }
};
```

#### Resource Service (`src/services/resourceService.ts`)

```typescript
import { 
  collection, 
  getDocs, 
  getDoc,
  doc,
  query, 
  orderBy, 
  limit,
  where,
  addDoc,
  updateDoc,
  deleteDoc,
  Timestamp,
  increment
} from 'firebase/firestore';
import { db } from './firebase/config';

export interface Resource {
  id: string;
  title: string;
  description: string;
  content: string;
  category: 'article' | 'report' | 'documentation' | 'guide';
  featured: boolean;
  thumbnailUrl: string;
  href: string;
  publishedDate: Timestamp;
  author?: string;
  tags: string[];
  viewCount: number;
  createdAt: Timestamp;
  updatedAt: Timestamp;
}

// READ: Get all resources
export const getResources = async (): Promise<Resource[]> => {
  try {
    const resourcesRef = collection(db, 'resources');
    const q = query(
      resourcesRef,
      orderBy('featured', 'desc'),
      orderBy('publishedDate', 'desc')
    );
    
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ 
      id: doc.id, 
      ...doc.data() 
    } as Resource));
  } catch (error) {
    console.error('Error fetching resources:', error);
    throw error;
  }
};

// READ: Get featured resources
export const getFeaturedResources = async (): Promise<Resource[]> => {
  try {
    const resourcesRef = collection(db, 'resources');
    const q = query(
      resourcesRef,
      where('featured', '==', true),
      orderBy('publishedDate', 'desc')
    );
    
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ 
      id: doc.id, 
      ...doc.data() 
    } as Resource));
  } catch (error) {
    console.error('Error fetching featured resources:', error);
    throw error;
  }
};

// CREATE: Add new resource (admin only)
export const createResource = async (
  resourceData: Omit<Resource, 'id' | 'viewCount' | 'createdAt' | 'updatedAt'>
): Promise<string> => {
  try {
    const docRef = await addDoc(collection(db, 'resources'), {
      ...resourceData,
      viewCount: 0,
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    });
    return docRef.id;
  } catch (error) {
    console.error('Error creating resource:', error);
    throw error;
  }
};

// UPDATE: Update resource (admin only)
export const updateResource = async (
  id: string,
  updates: Partial<Omit<Resource, 'id' | 'createdAt' | 'viewCount'>>
): Promise<void> => {
  try {
    const docRef = doc(db, 'resources', id);
    await updateDoc(docRef, {
      ...updates,
      updatedAt: Timestamp.now(),
    });
  } catch (error) {
    console.error('Error updating resource:', error);
    throw error;
  }
};

// Increment view count
export const incrementResourceViews = async (id: string): Promise<void> => {
  try {
    const docRef = doc(db, 'resources', id);
    await updateDoc(docRef, {
      viewCount: increment(1)
    });
  } catch (error) {
    console.error('Error incrementing view count:', error);
    throw error;
  }
};
```

#### Certificate Service (`src/services/certificateService.ts`)

```typescript
import { 
  collection, 
  getDocs, 
  query, 
  orderBy,
  addDoc,
  updateDoc,
  doc,
  Timestamp 
} from 'firebase/firestore';
import { db } from './firebase/config';

export interface Certificate {
  id: string;
  title: string;
  subtitle: string;
  description: string;
  price: number;
  currency: string;
  features: string[];
  comingSoon: boolean;
  enrollmentUrl?: string;
  imageUrl?: string;
  displayOrder: number;
  createdAt: Timestamp;
  updatedAt: Timestamp;
}

// READ: Get all certificates
export const getCertificates = async (): Promise<Certificate[]> => {
  try {
    const certsRef = collection(db, 'certificates');
    const q = query(certsRef, orderBy('displayOrder', 'asc'));
    
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ 
      id: doc.id, 
      ...doc.data() 
    } as Certificate));
  } catch (error) {
    console.error('Error fetching certificates:', error);
    throw error;
  }
};

// CREATE: Add new certificate (admin only)
export const createCertificate = async (
  certData: Omit<Certificate, 'id' | 'createdAt' | 'updatedAt'>
): Promise<string> => {
  try {
    const docRef = await addDoc(collection(db, 'certificates'), {
      ...certData,
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    });
    return docRef.id;
  } catch (error) {
    console.error('Error creating certificate:', error);
    throw error;
  }
};

// UPDATE: Update certificate (admin only)
export const updateCertificate = async (
  id: string,
  updates: Partial<Omit<Certificate, 'id' | 'createdAt'>>
): Promise<void> => {
  try {
    const docRef = doc(db, 'certificates', id);
    await updateDoc(docRef, {
      ...updates,
      updatedAt: Timestamp.now(),
    });
  } catch (error) {
    console.error('Error updating certificate:', error);
    throw error;
  }
};
```

### Caching Strategy

Implement a simple in-memory cache for FAQ data to reduce Firestore reads:

```typescript
// src/services/cacheService.ts
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

interface CacheEntry<T> {
  data: T;
  timestamp: number;
}

const cache = new Map<string, CacheEntry<any>>();

export const getCachedData = <T>(
  key: string,
  fetchFn: () => Promise<T>
): Promise<T> => {
  const cached = cache.get(key);
  const now = Date.now();
  
  if (cached && (now - cached.timestamp) < CACHE_DURATION) {
    return Promise.resolve(cached.data);
  }
  
  return fetchFn().then(data => {
    cache.set(key, { data, timestamp: now });
    return data;
  });
};

export const clearCache = (key?: string) => {
  if (key) {
    cache.delete(key);
  } else {
    cache.clear();
  }
};
```

## Quick Start Checklist

Follow these steps to set up Firestore for the InterpreLab landing page:

- [ ] 1. **Enable Firestore in Firebase Console**
  - Go to Firebase Console → Build → Firestore Database
  - Click "Create Database"
  - Select production mode
  - Choose database location (closest to your users)

- [ ] 2. **Copy Firebase Config**
  - Go to Project Settings → General
  - Scroll to "Your apps" → Web app
  - Copy `firebaseConfig` object
  - Create `src/services/firebase/config.ts`:
    ```typescript
    import { initializeApp } from 'firebase/app';
    import { getFirestore } from 'firebase/firestore';
    
    const firebaseConfig = {
      apiKey: process.env.VITE_FIREBASE_API_KEY,
      authDomain: process.env.VITE_FIREBASE_AUTH_DOMAIN,
      projectId: process.env.VITE_FIREBASE_PROJECT_ID,
      storageBucket: process.env.VITE_FIREBASE_STORAGE_BUCKET,
      messagingSenderId: process.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
      appId: process.env.VITE_FIREBASE_APP_ID,
    };
    
    const app = initializeApp(firebaseConfig);
    export const db = getFirestore(app);
    ```

- [ ] 3. **Set Environment Variables**
  - Create `.env.local` file in project root
  - Add Firebase config values (see example in `.env.example`)

- [ ] 4. **Create Collections**
  - Collections are auto-created when you add first document
  - Or create manually in Firestore Console

- [ ] 5. **Add Composite Indexes**
  - Go to Firestore Console → Indexes
  - Create indexes as specified in [Required Indexes](#required-indexes)

- [ ] 6. **Configure Security Rules**
  - Copy security rules from [Security Rules](#security-rules)
  - Go to Firestore Console → Rules
  - Paste and publish rules

- [ ] 7. **Create Service Files**
  - Create `src/services/faqService.ts`
  - Create `src/services/resourceService.ts`
  - Create `src/services/certificateService.ts`
  - Copy code from [CRUD Operations](#crud-operations)

- [ ] 8. **Seed Initial Data** (Optional)
  - Create a seed script or add documents manually via Firestore Console
  - Ensure each collection has at least one test document

- [ ] 9. **Test CRUD Operations**
  - Import service functions in a component
  - Test read operations first
  - Verify data displays correctly
  - Test write operations if you have admin access

- [ ] 10. **Deploy Security Rules**
  ```bash
  firebase deploy --only firestore:rules
  ```

## Additional Resources

- [Firestore Documentation](https://firebase.google.com/docs/firestore)
- [Security Rules Reference](https://firebase.google.com/docs/firestore/security/get-started)
- [Querying and Indexing](https://firebase.google.com/docs/firestore/query-data/queries)
- [Best Practices](https://firebase.google.com/docs/firestore/best-practices)

## Troubleshooting

### Common Issues

1. **"Missing index" error**
   - Click the link in the error message to auto-create the index
   - Or manually create in Firestore Console → Indexes

2. **Permission denied error**
   - Check security rules are deployed
   - Verify user authentication if required
   - Check rule conditions match your use case

3. **Slow query performance**
   - Ensure proper indexes are created
   - Implement caching for frequently accessed data
   - Use pagination with `limit()` for large collections

4. **Build fails with Firebase import errors**
   - Check Firebase SDK version compatibility
   - Ensure all Firebase packages are same version
   - Clear node_modules and reinstall

## Support

For questions or issues, contact the development team or refer to the main project README.
